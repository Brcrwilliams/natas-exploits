This challenge was certainly interesting. The application writes session data to a file and then reads it back later on. You have control of one part of the session data: your name.

The name is set by entering data into the name field. The PHP code that handles this is:
```
if(array_key_exists("name", $_REQUEST)) {
    $_SESSION["name"] = $_REQUEST["name"];
    debug("Name set to " . $_REQUEST["name"]);
}
```

So, the only thing we can control is $\_REQUEST["name"].

Here's what happens when the application reads the session file.
```
$data = file_get_contents($filename);
$_SESSION = array();
foreach(explode("\n", $data) as $line) {
    debug("Read [$line]");
$parts = explode(" ", $line, 2);
if($parts[0] != "") $_SESSION[$parts[0]] = $parts[1];
}
return session_encode();
```
So, first it splits the data on \\n and reads each line.  
Then, it splits each line on " " (space) and puts the first word as the key and the second word as the value in the session array. This means that if we can inject a new line (\\n) then we can add arbitrary key / value pairs. Can we do that? Let's check out the function that writes to the file. The code that does that is:

```
foreach($_SESSION as $key => $value) {
    debug("$key => $value");
    $data .= "$key $value\n";
}
file_put_contents($filename, $data);
chmod($filename, 0600);
```

So, this function just takes the session data, puts an \\n after each key / value pair, and then writes it to the file.

Remember that we can control one part of the session data, the value of the name. The \\n is equivalent to 0A in hex, so we can use BurpSuite and intercept the request where we set our name, and use %0A to inject a new line.

![injection](/images/natas201.png)

It worked!

![result](/images/natas202.png)
